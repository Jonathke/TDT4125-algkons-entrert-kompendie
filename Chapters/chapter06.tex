\section{Grådige Algoritmer og Lokale Søk}
Grådige algoritmer er noe som bør være kjent (kanskje til og med som noe av det enklere) fra tidligere fag. Lokalt søk har noen likheter med grådige algoritmer. Begge har den store fordelen av at de ofte er svært enkle å implementere, og gir også ofte grunnlag for teoretisk analyse av approksimeringer. 

Grådige algoritmer, formulert med språket som vi er blitt vant med nå, er algoritmer som starter med en ugyldig primal, og bygger løsningen gradvis. Alle valg som tas er bindende. Lokale søk derimot starter med en (gjerne arbitrær) gyldig primal og forsøker å opptimalisere den, mens den holder seg gyldig. Her er ingen valg bindende. Vi går i denne seksjonen raskt gjennom tre greie eksempler og analyserer approksimasjonsgraden.

\subsection{Sekvensering (Parallelle Maskinjobber)}
Dette er et greit problem, hvor vi har $m$ maskiner som skal fullføre $n$ jobber $j = 1...n$, der jobb $j$ har prosesseringstid $p_j$. En maskin kan kun holde på med en jobb om gangen, og må fullføre den når den er startet på. Målet er å minimere tiden det tar å fullføre alle jobbene, omtalt som $C_{max}$.

Et enkelt lokalt søk er som følger: Start med et arbitrært oppsett av jobber. Deretter flytt den jobben som er ferdig sist til den maskinen som i øyeblikket er ferdig tidligst, slik at $C_{max}$ synker. Fortsett å gjøre dette til det ikke lenger går (at jobben blir ikke blir flyttet), og output oppsettet. 

For analysen av approksimasjonsgraden her trenger vi to nedre grenser for $OPT = C^*_{max}$. De to åpenbare er at $C^*_{max} \leq max_j p_j$, og at $C^*_{max} \leq \sum\nolimits_j \frac{p_j}{m}$. Vi deler så inn i to intervaller for algoritmens output, før og etter siste jobb $p_j$ begynner (vi kaller det tidspunktet $s_j$. Ved tidspunktet $s_j$ har alle m maskinene jobbet konstant, og jobben j har ikke blitt startet på enda, altså har vi at $s_j \leq \sum\nolimits_{i\neq j} \frac{p_i}{m}$. Videre er $p_j \leq max_i p_i$. Dermed er det ikke vanskelig å se at $C_{max} = s_j + p_j = \sum\nolimits_{i\neq j} \frac{p_i}{m} + p_j = (1-\frac{1}{m})p_j + \sum\nolimits_i \frac{p_i}{m} \leq (2-\frac{1}{m})C^*_{max}$. Altså er vårt lokale søk en $(2-\frac{1}{m})$-approksimasjon.

For den grådige varianten av problemet, bare plasser ut jobber så snart en maskin har blitt ledig. Analysen her er nå mega-enkel, siden vi ser at når den grådige algoritmen er ferdig, vil den ha samme output-form som det lokale søke (altså hvis vi hadde forsøkt å kjøre det lokale søke på outputen til den grådige algoritmen, ville den bare ha outputta med en gang). Dermed er også dette en $(2-\frac{1}{m})$-approksimasjon. Dette kan videre forbedres til en $\frac{4}{3}$-approksimasjon ved å sortere lista av jobber for de mates til den grådige algoritmen. Detaljer finnes i boka/forelesning 6.

\subsection{Klynge-Analyse}
Her er oppgaven rimelig grei, målet er å finne $k$ senter blandt $n$ punkter. Slike senter er da noder som er "nærmest de andre". Litt mer formelt er målet å finne de punktene som gjør at radiusen til de sirklene som har punktene i midten og omfavner alle noder i grafen blir minst mulig. Den sentrale antagelsen i problemet er at vi befinner oss i såkalte metriske rom, der grafen er komplett, og kantene har vekter som kan sees på som "distanse" mellom nodene, altså at $d_{ij} \geq 0, d_{ij} = d_{ji}$ og at $d_{ik} + d_{kj} \geq d_{ij}$ (The triangle-inequality) holder for alle noder.

Her konstruerer vi enkelt en grådig algoritme som starter med å velge en arbitrær node å legger til i løsningen $S$. Så, for hver iterasjon tar den den noden som ligger lengst unna alle andre noder i $S$ og legger til i $S$. Dette fortsetter til $|S| = k$. Dette gir enkelt og greit en $2$-approksimasjon. For å se dette, anta først at alle noder i $S$ befinner seg i hver sin sirkel, med hensyn til $OPT = S^*$. Da ser vi med en gang at dette er en $2$-approksimasjon (en radius på $2r^*$ dekker hele sirkelen uansett hvor noden er plassert). Dersom $S$ inneholder to noder fra samme sirkel, betyr det at da det var den lengste avstanden i systemet, var maksimal avstand $\leq 2r^*$.

Det mest interessante her er at selvom det var såpass enkelt å oppnå en $2$-approksimasjon, ville det å oppnå så mye som en mikroskopisk smule bedre implisere at $P=NP$ . Grunnen til dette er at vi kunne brukte en $(2-\epsilon)$-approksimasjon for dette problemet til å bestemme om en graf har en dominerende mengde av $k$ noder (der $N(S)\cup S = V, S \subseteq V, |S| = k$) , et problem som er NP komplett. For å se dette, set $d_{ij} = 1$ dersom $(i,j)\in E$, ellers set $d_{ij} = 2$. Da holder fortsatt de metriske kravende, men en strengt bedre enn $2$-approksimasjon løser også dominerende set korrekt.

\subsection{Metric TSP eller Traveling Salesman IRL}
TSP er et velkjent problem, arguably det mest kjente av alle NP-komplette problem. Det er vist at så mye som en $\mathcal{O}(2^n)$-approksimasjon vil implisere at $P=NP$ (ikke så veldig vanskelig å se, reduser fra hamilton sykel). Men hva om vi legger på det metriske kravet fra forrige seksjon? Det er jo overhode ikke helt urimelig, ettersom det f.eks vil gjelde for TSP i "virkeligheten".

Vi lager en ganske straight-forward grådig algoritme, som starter med de to nærmeste nodene. Deretter legger den til den noden som nærmest disse to igjen, og utvider løsningen (som i Prims MSP). En fint bilde her er en strikk som strekker seg over en og en ekstra spiker, til den til slutt er innom alle noder.

Vi kan faktisk bruke Prim's MSP algoritme enda mer direkte. Dette kalles "Twice Around the Tree"-algoritmen (iallfall av Hetland...). Først, se at løsningen $MSP < OPT$, siden $OPT$ er den minste Hamilton syklen (fjern en kant, så har du et spenntre). Så vi starter med å bruke Prim's grådige algoritme for å finne et MSP. Deretter dobler vi alle kanter, og lager en euler-krets. Løsningen vår er nå rekkefølgen nodene traverseres i euler-kretsen (dvs. hopp over noder når de besøkes for ikke-første gang). Dette gir en $2$-approksimasjon, fordi ved å hoppe over noder (short-cutting) blir veien iallfall ikke lengre (siden $d_{ik} + d_{kj} \geq d_{ij}$). Videre er har vi bare doblet MSPen vår så løsningen vår $C \leq 2MSP \leq 2OPT$.

En slightly bedre algoritme har navn Christofides' algoritme. Poenget med kant-doblingen isted var å få partalls grad på alle noder. Men det er litt over-kill å doble alle nodene, så isteden ser vi kun på de nodene av odde grad. For disse nodene finner vi en perfekt matching av minimal kost (det må gå, siden det finnes et partall antall av dem, fordi summen av graden til alle nodene må være partallsgrad, siden hver kant legger på 2). Denne matchingen har da kost mindre enn $\frac{OPT}{2}$. Legger vi denne matchingen oppå MSPet vårt, så vil alle noder nå ha partalls grad, og vi kan lage en eulerkrets, og løse på samme måte som før. Vi får nå $C \leq MSP + \frac{OPT}{2} \leq \frac{3}{2}OPT$, så Christofides' algoritme er en $(\frac{3}{2})$-approksimasjon.
