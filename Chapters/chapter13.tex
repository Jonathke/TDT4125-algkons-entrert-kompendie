\section{Parametrisering}
Litt som i forrige seksjon, ønsker vi å se på noen litt andre definisjoner enn i resten av pensum. Dette er riktignok fremdeles relatert til kjøretid, men motivasjonen er at vi ønsker å kunne si noe mer om kjøretiden enn kun hvorvidt problemet kan løses polynomisk eller ikke. Litt mer spesifikt ønsker vi å se om problemer kan løses polynomisk, dersom vi fikserer visse parametre av problemet. Dette introduserer kompleksitetsklassene FPT (Fixed Parameter Tractable), og XP (Slicewise  Polynomial). For å beskrive disse kompleksitetsklassene, trenger vi først definisjonen på et parametrisert problem. Et parametrisert problem er $L \subseteq \sum\nolimits^{*} \times \mathbb{N}$ der vi typisk skriver det som $(x, k)$, hvor $x$ beskriver problemet, og $k$ er en fiksert parameter av problemet. Vi introduserer da følgene kompleksitetsklasser:

\begin{itemize}
    \item \textbf{FPT:} Problemets kjøretid er begrenset av $f(k)\cdot|(x,k)|^c$, for en konstant $c$
    \item \textbf{XP:} Problemets kjøretid er begrenset av $f(k)\cdot|(x,k)|^{g(k)}$
\end{itemize}

For ikke-synkende, og komputerbare funksjoner $f,g$. Merk at selvom de ser uskyldig like ut, er en FPT \emph{enormt} mye bedre enn en XP. Vi kaller en algoritme en FPT/XP-algoritme, dersom den viser at problemet den løser tilhører klassen FPT/XP. Vi ser på et par raske eksempler, og plasserer dem i kompleksitetsklasser.

\subsection{The Good, the Bad and the Ugly}

Nodedekke er et kjent NP-komplett problem, som vi har diskutert litt rundt tidligere. Men hva om vi forsøker å fiksere en $k$, slik at vi spør om det eksisterer et nodedekke av størrelse $k$? Altså vi ønsker å se på en instans av nodedekke som et parametrisert problem $(G,k)$, der $G = (V,E)$ beskriver grafen, og $k$ er maksimal størrelse på nodedekket vi ønsker å finne. Vi skal i de to neste seksjonene se at vi kan redusere problemet til å løses i tid $\mathcal{O}(2^kk\cdot n)$, for $n = |V|$ (faktisk skal vi se at vi kan klare enda litt bedre også). Ser vi på definisjonene, er det dermed lett å se at dette er en FPT-algoritme (for $c=1$).

Videre følger et eksempel der vi ikke klarer å oppnå de ønskelige resultatene våre fullt så lett for et slikt naturlig valg av $k$ (sannsynligvis ikke i det hele tatt). Betrakt nå heller problem nodefargelegging $(G,k)$, der vi ønsker å fargelegge nodene i en graf $G = (V,E)$ i $k$ forskjellige farger, slik at for hver kant $(u,v) \in E$ har vi forskjellige farger på $u,v$. Dette problemet er i det generelle tilfelle NP-komplett, men kanskje vi kunne håpet på en lignende situasjon som i forrige avsnitt, der vi finner polynomiske løsninger for fikserte verdier av $k$? Dessverre viser det seg at $k$-fargelegging av noder er NP-komplett for $k\geq 3$, noe som gjør at dersom node-fargelegging var i enten FPT eller XP, ville det med en gang implisert at $P=NP$. Dermed finnes det trolig ingen XP-algoritme engang for node-fargelegging.

Det siste eksempelet for nå er et til klassisk NP-komplett problem, nemlig CLIQUE problemet. Om vi ser på det parametriserte problemet $(G,k)$, der $k$ betegner størrelsen på klikken vi ønsker å finne, finnes det en ganske triviell XP-algoritme (som løser problemet i $\mathcal{O}(n^k)$ tid). Vi ser på alle de ${n \choose k} = \mathcal{O}(\frac{n^k}{k^2})$ subsettene av størrelse $k$, og skjekker om hver av dem er en klikk (i tid $\mathcal{O}(k^2)$). Dessverre finnes det så langt ingen FPT-algoritmer for dette parametriserte problemet. Men, vi kan heller ikke vise på lignende måte som isted at det ville implisert $P=NP$. For å se dette, se at isted brukte vi det at $k$-node-fargelegging var NP-komplett for $k \geq 3$. En lignende grense for CLIQUE kan ikke eksistere, med mindre $P=NP$, for da kunne vi brukt XP-algoritmen til å løse problemet i polynomisk tid. I følge boka er dette heller regelen enn unntaket, at vi ikke kan bruke NP-hardhet til å forklare hvorfor vi ikke finner FPT algoritmer, når vi har XP algoritmer.

Men, CLIQUE illustrerer også et annet viktig poeng. Valg av parametrisering er ekstremt viktig. Ser vi heller på den parametriserte versjonen for CLIQUE som $(G,\Delta)$, der $\Delta = max\{d(v):v\in V \}$ (den maksimale node-graden), kan vi finne en FPT-algoritme som kjører i $\mathcal{O}(2^\Delta \Delta^2 \cdot n)$. Se boka for detaljer.

\subsection{Kernelization}
Idéen bak Kernelization er å redusere en problem instans mest mulig, til kun "kjernen" av problemet står igjen. Vi lager en preprosseserings algoritme som reduserer problem-instansen $(I,k)$ til $(I',k')$ på "safe" måte, dvs. at svaret ikke endrer seg. En slik algoritme $\mathcal{A}$ kalles en \emph{kernelization algorithm} eller bare en \emph{kernel} dersom $size_{A}(k) \leq g(k)$ for en komputerbar funksjon $g: \mathbb{N}\rightarrow \mathbb{N}$, hvor $size_{A}(k)$ betegner størrelsen på outputen eller problemets \emph{kernel}, og $\mathcal{A}$ kjører i polynomisk tid. Med andre ord trenger vi at $\mathcal{A}$ reduserer problemet til et ekvivalent problem, der størrelsen er begrenset av en funksjon av $k$. Videre har vi et resultat som viser at at et problem har en \emph{kernel} hvis og bare hvis den er i FPT. Se detaljer i boken. Det påpekes at selvom dette er et viktig resultat teoretisk resultat, er denne \emph{kernelen} som regel ikke veldig praktisk anvendbar (den er gjerne eksponensiell i $k$, mens som vi skal se kan vi ofte klare å oppnå kvadratiske, eller til og med lineære kjerner i $k$). Merk at vi bedømmer hvor bra $\mathcal{A}$ er utifra $size_{A}(k)$, og ikke kjøretiden til $\mathcal{A}$. Vi krever kun at den er polynomisk.

\subsubsection{Vertex Cover/Nodedekke}
Vi ser litt mer nøye på nodedekke. Vi ønsker å finne såkalte reduksjonsregler, slik at vi kan redusere nodedekke til sin \emph{kernel}. Vi skriver et par observasjoner, og fra de deduserer vi reduksjonsreglene. Det første å merke seg er at dersom $v$ er en isolert node ($N(v) = \varnothing$), så vet vi at $v$ åpenbart ikke er med i noen nodedekker. Motsatt vei kan vi tenke oss at dersom node $v$ har $d(v) \geq k+1$, så må $v$ være i alle nodedekker av størrelse $k$ eller mindre (alltid må enten $v$ eller $N(v)$ være i nodedekke). Etter å ha fjærnet disse nodene fra problemet, se på antall noder og antall kanter i grafen, gitt at vi skal kunne finne et nodedekke av maks $k$ noder. La $S$ betegne dette nodedekke. Hver node i $S$ har grad maksimalt $k$, og $S$ selv består av maksimalt $k$ noder. Da er det ikke vanskelig å se at et $k$-nodedekke er umulig dersom $|V| > k^2 + k$. Videre kan $S$ kantene dekke maks $|S|k$ kanter. Dermed vet vi også at det er umulig dersom $|E| > k^2$. Vi er nå klare for å skrive ned reduksjonsreglene.

\begin{itemize}
    \item \textbf{VC.1:} Dersom $G$ inneholder en node isolert node $v$, lager vi en ny instans av problemet $(G,k)$, der $G = (V\setminus \{v\},E)$.
    \item \textbf{VC.2:} Dersom det finnes en node $v$ med $d(v) \geq k+1$, lager vi en ny instans av problemet $(G,k-1)$, der $G = (V\setminus \{v\},E')$, der $E'$ er kantene etter at vi har fjernet de som lå intil $v$.
    \item \textbf{VC.3:} La $(G,k)$ være en instans, der hverken VC.1 eller VC.2 er relevante. Dersom $k > 0$, og $|V| > k^2 + k$ eller $|E| > k^2$, vet vi at et nodedekke er umulig (output "nei").
\end{itemize}
Alle disse reduksjonsreglene kjører helt åpenbart i lineær tid, så som en konsekvens (særlig av VC.3) får vi at nodedekke har en \emph{kernel} med $\mathcal{O}(k^2)$ noder og $\mathcal{O}(k^2)$ kanter.

\subsubsection{Feedback Arc Set In Tournaments}
Dette problemet er tilsvarende "Sykelkritiske noder" som tidligere omtalt, bortsett fra at vi er interessert i en løsning bestående av kanter. Videre er grafen vår $T = (V,E)$ en såkalt turnering. En turnering er en komplett graf med orientering (for alle noder $u,v \in V$ har vi nøyaktig en av $(u,v)$ eller $(v,u)$). Vi ønsker da å fjærne maksimalt $k$ kanter som fjærner alle sykler i $T$. Analysen her er litt mer teknisk enn for nodedekke, så jeg skriver heller kun opp reduksjonsreglene. Se evt. boka. Med triangler menes sykler bestående av nøyaktig $3$ kanter.

\begin{itemize}
    \item \textbf{FAST.1:} Dersom en kant $e$ er del av minst $k+1$ triangler, lager vi en ny instans av problemet $(T,k-1)$ der $T = (V,E\setminus \{e\})$
    \item \textbf{FAST.2:} Dersom en kant $v$ ikke er del av noe triangel, lag en ny instans $(T,k)$ der $T = (V\setminus \{v\},E')$ hvor $E'$ er de kantene som er igjen når vi "shortcutter" $v$.
\end{itemize}
Merk at i analysen i boka snur de kanter fremfor å fjærne dem. Det at FAST.2 er "safe" er ikke trivielt, se evt. boka for bevis. Videre gir analysen vår at FEEDBACK ARC SET IN TURNAMENTS har en \emph{kernel} bestående av maksimalt $k^2 + 2k$ noder.

\subsubsection{Edge Clique Cover}
Et tredje problem som vi ønsker å finne en kjerne til. Målet i dette problemet er for en graf $G=(V,E)$ å si om vi kan dekke hele $E$ med maksimalt $k$ klikker. Det viser seg at den optimale \emph{kernelen} til EDGE CLIQUE COVER er eksponensiell i $k$ (utenfor pensum). Vi gir igjen simpelthen reduksjonsreglene.

\begin{itemize}
    \item \textbf{ECC.1:} Dersom $G$ inneholder en node isolert node $v$, lag en ny instans $(G,k)$, der $G = (V\setminus \{v\},E)$.
    \item \textbf{ECC.2:} Dersom det finnes en isolert kant $e=(u,v)$ ($u,v$ har begge grad $1$), lag en ny instans $(G,k-1)$, der $G = (V\setminus \{u,v\},E\setminus \{e\})$
    \item \textbf{ECC.3:} Dersom det finnes en kant $e=(u,v)$ der $N[u] = N[v]\;(N[x] = N(x) \cup \{x\})$, lag en ny instans $(G,k-1)$, der $G = (V\setminus \{v\},E')$ hvor $E'$ er kantene etter at vi har fjærnet de som lå intill $v$.
\end{itemize}
Her er ECC.1 og ECC.2 ganske trivielle, mens ECC.3 er den smarte. To slike såkalte "true twins" kan behandles helt likt for optimum (alle klikkene $u$ er med i er også $v$ med i), så de kan reduseres. Slike noder gir også en god analyse for størrelsen på kjernen, som består av $\mathcal{O}(2^k)$ kanter. For å se dette, la $C_1,...,C_k$ være klikkene i løsningen. Ingen to noder kan være del av nøyaktig de samme klikkene i løsningen (ellers hadde de vært "true twins" og hadde blitt redusert), og det finnes kun $2^k$ forskjellige kombinasjoner. Dermed, om $|V| \geq 2^k+1$ må en node $v$ (husk $d(v)\geq 1$) ikke være med i noen av klikkene, og dermed kan ikke de kantene som er intil $v$ være dekte av løsningen.

\subsection{Bounded Search Tree}
Idéen her er veldig enkel, men effektiv for parametriserte problemer. Vi gjetter på et hvis en liten del av en løsning, og får en ny, mindre instans av problemet. Dette gjør vi rekursivt, til problemet er trivielt å løse. Dersom det ikke er løsbart "backtracker" vi, og forsøker å gjette anderledes. Dette kan tolkes som å konstruere og søke gjennom et søketre for problemet vi forsøker å løse. Det enkleste er nok å gå igjennom et eksempel, men først ser vi på et par formelle krav.

Vi har en instans $I$ av et problem. I en branch reduserer vi til $I_1,...,I_l$, hvor iallfall en av subproblemene inneholder løsningen, om den finnes. $l$ må være liten nok, og videre må hver branch redusere størrelsen problemet nok. Litt mer formelt må $l \leq f(|I|)$, og videre har vi at $|I_i| \leq |I| - c$ for en konstant $c \geq 0$. Det vi gjerne ønsker å gjøre for å finne kjøretiden til en slik algoritme, er å finne en grense for antall noder i søketreet, ofte basert på antall løvnoder. Videre må vi vite noe om hvor lang tid vi bruker i hver node.

Vi ser igjen mer på nodedekke, med målet om å nå kjøretiden nevnt i introduksjonen. Vi baserer algoritmen på to enkle fakta: For en node $v$ er som nevnt tidligere alltid enten $v$ eller $N(v)$ med i løsningen. Videre er nodedekke helt trivielt når den maksimale nodegraden i en graf er $1$. Dermed er en naturlig branching i grafen å enten velge $v$ eller $N(v)$. Ved hver node velger vi alltid den $v$ med maksimal grad. Videre benytter vi reduksjonsreglene i hver node. I den branchen hvor vi velger $v$ senker vi $k$ med $1$, mens i den andre branchen senker vi $k$ med $|N(v)| \geq 2$. Som tidligere diskutert er tid brukt i hver node $\mathcal{O}(n^{\mathcal{O}(1)})$. Det gjenstår dermed å finne et uttrykk for antall noder i søketreet. Vi kan sette opp en rekursiv formel for antall noder som $T(i) \geq T(i-1) + T(i-2), i\geq 2$, og $T(1) = T(0) = 1$ Dette er klart fra måten vi brancher. Dette gir en grenseverdi på $T(k) \leq 1.6181^k$ (se boka for utregning). Dette gir resultatet om at nodedekke kan løses i $\mathcal{O}(n\sqrt{m}+1.6181^kk^{\mathcal{O}(1)})$. Faktisk kan vi forbedre dette ved å se at nodedekke også er trivielt løslig når maksimal nodegrad er $2$. Samme utregning oppnår da en kjøretid på $\mathcal{O}(n\sqrt{m}+1.4656^kk^{\mathcal{O}(1)})$



